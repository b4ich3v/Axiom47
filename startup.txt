## One-time build (images)

```powershell
docker compose -f docker/docker-compose.dev.yml build --no-cache
```

> Bash/Zsh is the same; just replace backslashes if you copy paths.

## Start (detached)

Start everything (control + two demo agents):

```powershell
docker compose -f docker/docker-compose.dev.yml up -d
```

Start only the control plane:

```powershell
docker compose -f docker/docker-compose.dev.yml up -d control
```

### Rebuild & start after code changes

- Rebuild **control** and restart it:
  ```powershell
  docker compose -f docker/docker-compose.dev.yml up -d --build control
  ```
- Rebuild **all** services and restart:
  ```powershell
  docker compose -f docker/docker-compose.dev.yml up -d --build
  ```

## Stop / Down

- Stop (containers stay created):
  ```powershell
  docker compose -f docker/docker-compose.dev.yml stop
  ```
- Down (remove containers & network; images remain):
  ```powershell
  docker compose -f docker/docker-compose.dev.yml down
  ```

## Logs & Status

```powershell
# status
docker compose -f docker/docker-compose.dev.yml ps

# follow control logs
docker compose -f docker/docker-compose.dev.yml logs -f control

# follow agents
docker compose -f docker/docker-compose.dev.yml logs -f agent1
docker compose -f docker/docker-compose.dev.yml logs -f agent2
```

## UI & API

- Devices: <http://127.0.0.1:8080/ui/devices>  
- Rollouts: <http://127.0.0.1:8080/ui/rollouts>  
- Health: <http://127.0.0.1:8080/healthz>  

### Useful API calls

Create a rollout:

```powershell
curl -s -X POST "http://127.0.0.1:8080/api/rollouts" `
  -H "Content-Type: application/json" `
  -d '{"tenant":"demo-tenant","artifact":"app:v2.1.2","channel":"canary","selector":{"role":"kiosk"},"waves":2}'
```

Start a rollout (two endpoints are supported; either works):

```powershell
curl -s -X POST "http://127.0.0.1:8080/api/rollouts/<ROLL_ID>:start"
# or
curl -s -X POST "http://127.0.0.1:8080/api/rollouts/<ROLL_ID>/start"
```

List rollouts:

```powershell
curl -s "http://127.0.0.1:8080/api/rollouts"
```

Rollout runs (per-wave history):

```powershell
curl -s "http://127.0.0.1:8080/api/rollouts/<ROLL_ID>/runs"
```

Simulate bucket split across waves (read-only plan):

```powershell
curl -s -X POST "http://127.0.0.1:8080/api/rollouts/<ROLL_ID>:simulate?waves=3"
```

List devices:

```powershell
curl -s "http://127.0.0.1:8080/api/devices"
```

## Scheduler knobs (optional)

You can tune rollout pacing via env vars in `docker/docker-compose.dev.yml` (service `control`):

```yaml
environment:
  - XDP47_SCHED_INTERVAL=10s      # delay between waves
  - XDP47_SCHED_GRACE=90s         # heartbeat grace window
  - XDP47_SCHED_REQUIRE_OK=false  # require 'ok' health to advance
  - XDP47_SCHED_SKIP_OFFLINE=true # skip devices without recent heartbeat
```

Apply changes:

```powershell
docker compose -f docker/docker-compose.dev.yml up -d --build control
```

## Typical workflows

### Restart only control after UI/API change
```powershell
docker compose -f docker/docker-compose.dev.yml up -d --build control
docker compose -f docker/docker-compose.dev.yml logs -f control
```

### Full clean rebuild
```powershell
docker compose -f docker/docker-compose.dev.yml down
docker compose -f docker/docker-compose.dev.yml build --no-cache
docker compose -f docker/docker-compose.dev.yml up -d
```

## Troubleshooting

- **Port 8080 busy**  
  Stop whatever uses 8080 or adjust `ports:` in the compose file.

- **UI shows garbled dashes like `XDP47 â€” Devices`**  
  Ensure source files are saved in **UTF-8**. Then rebuild control:
  ```powershell
  docker compose -f docker/docker-compose.dev.yml up -d --build control
  ```

- **Rollout shows `failed`**  
  Increase `XDP47_SCHED_GRACE` or set `XDP47_SCHED_REQUIRE_OK=false`.  
  Check per-wave history:
  ```powershell
  curl -s "http://127.0.0.1:8080/api/rollouts/<ROLL_ID>/runs"
  ```

---

### Notes

- The demo agents auto-register as devices and periodically heartbeat.  
- The control plane persists data inside its container filesystem in this dev setup (no external DB). For a clean slate, run `down` and `up -d` again; for production, wire an external Postgres.
